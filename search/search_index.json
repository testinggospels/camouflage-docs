{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Camouflage Service Virtualization Camouflage is a backend mocking tool for HTTP, gRPC, Websockets and Thrift protocols , which helps you carry out your front end prototyping, unit testing, functional/performance testing in silos, in absence of one or more Microservices/APIs. History Camouflage was born as a small tool inspired by namshi/mockserver . Mockserver felt like a breath of fresh air, compared to the other tools at the moment which required you to remember tool specific JSON schema to be able to create/manage your mocks. If not, it came with complex GUIs and some tool specific terminologies. And let's face it, no one wants to \"learn\" how to create mocks. It just something we have to do so that we can focus on what we actually want to do, which is building frontend prototypes and independent microservices without waiting for everything to be ready. Camouflage took that idea from mockserver, which allows you to create mocks in seconds, no learning curve, no JSON schema, no specific terminologies. Just copy and paste your expected response in a mock file and you're good to go. And of course, if you want to enhance the mocks, Camouflage provides you intuitive ways to do that. Technically you could build a fully functional backend connected to a database using Camouflage. We wouldn't recommend doing so! Just saying you could...if you don't want to live by the rules and enjoy chaos. First version of Camouflage was something that wasn't built to scale. It was a hobby project, built to do the job in line with requirements of one specific organization. It quickly became apparant that the code was clunky, extending it was a nightmare and maintaining it...well, there is a reason why it collects dust at v0.15.0, staring longingly at v1.0.0, a desitination it knows it'll never arrive at. So here we are, making a second attempt at simplifying mocking/service virtualization. Let's dive in. What has changed Extensible by design Camouflage is no longer a rigid tool. It's now a flexible library you use to build your own tool. You write code to configure the mock server the way you want. You use your middlewares of choice, write your own reusable custom helpers and all of that just plays along with core Camouflage functionalities. Lightweight and modular Instead of downloading one large tool which contains code for things you are never going to use, you only download things you need. Camouflage now comes with 6 modules: @camouflage/helpers @camouflage/http @camouflage/grpc @camouflage/websockets - WIP @camouflage/thrift - WIP @camouflage/soap - WIP Improved security Reduced usage of eval() . Since you use it as a library now, if your routes can not be built using Camouflage, you can just add functionalities to the Camouflage app like you would if you were creating a route in a normal express app. Caution There are a few features that have been dropped to keep things simple. These features were not extensively used or were security risks based on the feedback we got in our previous attempt. We have dropped helpers such as code , pg and proxy . You can always add them back in. Creating custom handlebar helpers is easier than ever. No backup and restore features. This allows you the freedom to write your own cron jobs or store the project on S3 like cloud services. No distributed mode. Single instance of Camouflage should be fairly scalable and support large loads. Let's get started.","title":"Camouflage Service Virtualization"},{"location":"#camouflage-service-virtualization","text":"Camouflage is a backend mocking tool for HTTP, gRPC, Websockets and Thrift protocols , which helps you carry out your front end prototyping, unit testing, functional/performance testing in silos, in absence of one or more Microservices/APIs.","title":"Camouflage Service Virtualization"},{"location":"#history","text":"Camouflage was born as a small tool inspired by namshi/mockserver . Mockserver felt like a breath of fresh air, compared to the other tools at the moment which required you to remember tool specific JSON schema to be able to create/manage your mocks. If not, it came with complex GUIs and some tool specific terminologies. And let's face it, no one wants to \"learn\" how to create mocks. It just something we have to do so that we can focus on what we actually want to do, which is building frontend prototypes and independent microservices without waiting for everything to be ready. Camouflage took that idea from mockserver, which allows you to create mocks in seconds, no learning curve, no JSON schema, no specific terminologies. Just copy and paste your expected response in a mock file and you're good to go. And of course, if you want to enhance the mocks, Camouflage provides you intuitive ways to do that. Technically you could build a fully functional backend connected to a database using Camouflage. We wouldn't recommend doing so! Just saying you could...if you don't want to live by the rules and enjoy chaos. First version of Camouflage was something that wasn't built to scale. It was a hobby project, built to do the job in line with requirements of one specific organization. It quickly became apparant that the code was clunky, extending it was a nightmare and maintaining it...well, there is a reason why it collects dust at v0.15.0, staring longingly at v1.0.0, a desitination it knows it'll never arrive at. So here we are, making a second attempt at simplifying mocking/service virtualization. Let's dive in.","title":"History"},{"location":"#what-has-changed","text":"","title":"What has changed"},{"location":"#extensible-by-design","text":"Camouflage is no longer a rigid tool. It's now a flexible library you use to build your own tool. You write code to configure the mock server the way you want. You use your middlewares of choice, write your own reusable custom helpers and all of that just plays along with core Camouflage functionalities.","title":"Extensible by design"},{"location":"#lightweight-and-modular","text":"Instead of downloading one large tool which contains code for things you are never going to use, you only download things you need. Camouflage now comes with 6 modules: @camouflage/helpers @camouflage/http @camouflage/grpc @camouflage/websockets - WIP @camouflage/thrift - WIP @camouflage/soap - WIP","title":"Lightweight and modular"},{"location":"#improved-security","text":"Reduced usage of eval() . Since you use it as a library now, if your routes can not be built using Camouflage, you can just add functionalities to the Camouflage app like you would if you were creating a route in a normal express app. Caution There are a few features that have been dropped to keep things simple. These features were not extensively used or were security risks based on the feedback we got in our previous attempt. We have dropped helpers such as code , pg and proxy . You can always add them back in. Creating custom handlebar helpers is easier than ever. No backup and restore features. This allows you the freedom to write your own cron jobs or store the project on S3 like cloud services. No distributed mode. Single instance of Camouflage should be fairly scalable and support large loads. Let's get started.","title":"Improved security"},{"location":"getting-started/","text":"Getting Started Create a new project, and install the Camouflage modules you need. Available modules are: @camouflage/helpers @camouflage/http @camouflage/grpc @camouflage/websockets - WIP @camouflage/thrift - WIP @camouflage/soap - WIP Quick Start @camouflage/helpers Camouflage helpers form the backbone of each protocol. You can build your mocks without them, but helpers add advanced features to your mocks. You can chose the protocol specific package that you need to download from the following list, however helpers are required for every Camouflage project. Install helpers npx jsr add @camouflage/helpers When you create a helper object, it loads some inbuilt helpers that are listed here . Once you have the object, you only need to parse your template string. import Helpers from \"@camouflage/helpers\"; const helpers = new Helpers(); const todaysDate = helpers.parse(\"{{now format='yyyy-MM-dd'}}\"); console.log(todaysDate); // 2023-12-21 Helpers class takes in two arguments i.e. injectionAllowed and loglevel . @camouflage/http Camouflage HTTP Module helps you create mocks for your http/https/http2 endpoints. To start install @camouflage/http in your project. npx jsr add @camouflage/http Once you have the required packages installed, you can start your http server as shown below. import CamouflageHttp from \"@camouflage/http\"; const camouflageHttp = new CamouflageHttp(); camouflageHttp.loadConfigFromJson(\"./config.json\"); /** * You can follow the instructions in the link below * to generate self signed certificates if you don't already have them. * https://www.akadia.com/services/ssh_test_certificate.html * FOR HTTPS/HTTP2 servers, you would need to setup credentials * const httpsServerOptions = { * key: fs.readFileSync(\"location/to/server.key\"), * cert: fs.readFileSync(\"location/to/server.crt\"), * // more options * }; * camouflageHttp.setServerOptionsHttps(httpsServerOptions); * */ camouflageHttp.start(); Read more about Camouflage http module here @camouflage/gprc Camouflage GRPC Module helps you create mocks for your grpc endpoints. To start, install @camouflage/grpc in your project. npx jsr add @camouflage/grpc Once you have the required packages installed, you can start your grpc server as shown below. import CamouflageGrpc, { CamouflageGrpcHandler } from \"@camouflage/grpc\"; import * as protoloader from \"@grpc/proto-loader\"; import * as grpc from \"@grpc/grpc-js\"; // Create CamouflageGrpc object and load config. const camouflageGrpc = new CamouflageGrpc(); camouflageGrpc.loadConfigFromJson(\"./config_grpc.json\"); // Get an instance of available camouflage grpc handlers const handlers = camouflageGrpc.getHandlers(); // Load your proto file const blogPackageDef = protoloader.loadSync(\"./blog.proto\", {}); const blogGrpcObject = grpc.loadPackageDefinition(blogPackageDef); const blogPackage = blogGrpcObject.blogPackage; if (handlers) { /** * Depending on the type of your method, use one of available handlers * i.e. * - unaryHandler * - serverSideStreamingHandler * - clientSideStreamingHandler * - bidiStreamingHandler * * Add your service to Camouflage server. * */ camouflageGrpc.addService(blogPackage.BlogService.service, { createBlog: handlers.unaryHandler, listBlogs: handlers.unaryHandler, }); } camouflageGrpc.start(); Read more about Camouflage grpc module here @camouflage/websockets WIP @camouflage/thrift WIP @camouflage/soap WIP","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Create a new project, and install the Camouflage modules you need. Available modules are: @camouflage/helpers @camouflage/http @camouflage/grpc @camouflage/websockets - WIP @camouflage/thrift - WIP @camouflage/soap - WIP","title":"Getting Started"},{"location":"getting-started/#quick-start","text":"","title":"Quick Start"},{"location":"getting-started/#camouflagehelpers","text":"Camouflage helpers form the backbone of each protocol. You can build your mocks without them, but helpers add advanced features to your mocks. You can chose the protocol specific package that you need to download from the following list, however helpers are required for every Camouflage project. Install helpers npx jsr add @camouflage/helpers When you create a helper object, it loads some inbuilt helpers that are listed here . Once you have the object, you only need to parse your template string. import Helpers from \"@camouflage/helpers\"; const helpers = new Helpers(); const todaysDate = helpers.parse(\"{{now format='yyyy-MM-dd'}}\"); console.log(todaysDate); // 2023-12-21 Helpers class takes in two arguments i.e. injectionAllowed and loglevel .","title":"@camouflage/helpers"},{"location":"getting-started/#camouflagehttp","text":"Camouflage HTTP Module helps you create mocks for your http/https/http2 endpoints. To start install @camouflage/http in your project. npx jsr add @camouflage/http Once you have the required packages installed, you can start your http server as shown below. import CamouflageHttp from \"@camouflage/http\"; const camouflageHttp = new CamouflageHttp(); camouflageHttp.loadConfigFromJson(\"./config.json\"); /** * You can follow the instructions in the link below * to generate self signed certificates if you don't already have them. * https://www.akadia.com/services/ssh_test_certificate.html * FOR HTTPS/HTTP2 servers, you would need to setup credentials * const httpsServerOptions = { * key: fs.readFileSync(\"location/to/server.key\"), * cert: fs.readFileSync(\"location/to/server.crt\"), * // more options * }; * camouflageHttp.setServerOptionsHttps(httpsServerOptions); * */ camouflageHttp.start(); Read more about Camouflage http module here","title":"@camouflage/http"},{"location":"getting-started/#camouflagegprc","text":"Camouflage GRPC Module helps you create mocks for your grpc endpoints. To start, install @camouflage/grpc in your project. npx jsr add @camouflage/grpc Once you have the required packages installed, you can start your grpc server as shown below. import CamouflageGrpc, { CamouflageGrpcHandler } from \"@camouflage/grpc\"; import * as protoloader from \"@grpc/proto-loader\"; import * as grpc from \"@grpc/grpc-js\"; // Create CamouflageGrpc object and load config. const camouflageGrpc = new CamouflageGrpc(); camouflageGrpc.loadConfigFromJson(\"./config_grpc.json\"); // Get an instance of available camouflage grpc handlers const handlers = camouflageGrpc.getHandlers(); // Load your proto file const blogPackageDef = protoloader.loadSync(\"./blog.proto\", {}); const blogGrpcObject = grpc.loadPackageDefinition(blogPackageDef); const blogPackage = blogGrpcObject.blogPackage; if (handlers) { /** * Depending on the type of your method, use one of available handlers * i.e. * - unaryHandler * - serverSideStreamingHandler * - clientSideStreamingHandler * - bidiStreamingHandler * * Add your service to Camouflage server. * */ camouflageGrpc.addService(blogPackage.BlogService.service, { createBlog: handlers.unaryHandler, listBlogs: handlers.unaryHandler, }); } camouflageGrpc.start(); Read more about Camouflage grpc module here","title":"@camouflage/gprc"},{"location":"getting-started/#camouflagewebsockets","text":"WIP","title":"@camouflage/websockets"},{"location":"getting-started/#camouflagethrift","text":"WIP","title":"@camouflage/thrift"},{"location":"getting-started/#camouflagesoap","text":"WIP","title":"@camouflage/soap"},{"location":"grpc/","text":"GRPC GRPC module of Camouflage lets you mock your backends based on grpc protocols. You can create a Camouflage grpc object from CamouflageGrpc class and configure it to serve mocks for your incoming requests. Start by installing required dependencies npx jsr add @camouflage/grpc You can create the Camouflage object without any parameters, and load the required options as needed import CamouflageGrpc from \"@camouflage/grpc\"; import * as protoloader from \"@grpc/proto-loader\"; import * as grpc from \"@grpc/grpc-js\"; const camouflageGrpc = new CamouflageGrpc(); camouflageGrpc.loadConfigFromJson(\"./config_grpc.json\"); //...add your services camouflageGrpc.start(); Or you can create the Camouflage object with the options import CamouflageGrpc, { CamouflageGrpcConfig } from \"@camouflage/grpc\"; const config = {}; const camouflageGrpc = new CamouflageGrpc(config); camouflageGrpc.start(); Available methods loadConfigFromJson = (configFilePath: string): void While you can include your config as part of your code and ensure the types yourself, you may at times want to maintain the configuration for your Camouflage server separate from the application code. This is usually a good practice from maintainability point of view, or even practical if you want to maintain multiple config files for different usecases. loadConfigFromJson lets you load a config via a .json file. You don't need to worry about validating your config file, Camouflage takes care of validating your config and prints relevant errors which help you fix your config files, if you miss something. getHandlers = (): CamouflageGrpcHandler | undefined Camouflage provides some ready to use handlers which you can use to load your services/methods into the Camouflage grpc servers. Depending on the type of method your mocks require, you can use one of the following: unaryHandler serverSideStreamingHandler clientSideStreamingHandler bidiStreamingHandler getHelpers = (): Helpers When you create a CamouflageGrpc object, it automatically creates an instance of helpers. You can use getHelpers() to get a reference to this helpers object. This is useful when you want add custom helpers that are specific to your requirements. import Helpers from \"@camouflage/helpers\"; const helpers = camouflageGrpc.getHelpers(); helpers.addHelper(\"ping\", (context) => { return \"pong\"; }); camouflageGrpc.start(); You can take a look at how inbuilt helpers have been created, in case you want to understand how custom helpers can be created. Refer to the helper source code addService = (service: grpc.ServiceDefinition , implementation: grpc.UntypedServiceImplementation): void camouflageGrpc.addService is wrapper on @grpc/grpc-js addService method. It allows you to load your proto package definitions/services/methods into Camouflage's grpc server. In the following example we load the blog.proto definition into a grpcObject and use it to provide implementation of the createBlog and listBlogs methods required by the proto definition import CamouflageGrpc, { CamouflageGrpcHandler } from \"@camouflage/grpc\"; import * as protoloader from \"@grpc/proto-loader\"; import * as grpc from \"@grpc/grpc-js\"; const camouflageGrpc = new CamouflageGrpc(); camouflageGrpc.loadConfigFromJson(\"./config_grpc.json\"); const handlers = camouflageGrpc.getHandlers(); const blogPackageDef = protoloader.loadSync(\"./blog.proto\", {}); const blogGrpcObject = grpc.loadPackageDefinition(blogPackageDef); const blogPackage = blogGrpcObject.blogPackage; if (handlers) { camouflageGrpc.addService(blogPackage.BlogService.service, { createBlog: handlers.unaryHandler, listBlogs: handlers.unaryHandler, }); } camouflageGrpc.start(); Here we are using Camouflage's unaryHandler as the implementation of the required methods, but you might as well write your own implementation, making it easier to mock only the required methods instead of everything. start = async (): Promise Self explanatory. Starts the Camouflage grpc server. stop = async (): Promise Self explanatory. Stops the Camouflage grpc server. Hooks Note COMING SOON Camouflage GRPC Configuration You can provide following configuration options in your config.json file and load it to Camouflage before you start the server { \"log\": { \"enable\": true, // enables or disables the logs \"level\": \"trace\" // // if enable=true, sets the log level. Available options are \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\" }, \"host\": \"0.0.0.0\", // host part of the address on which you'd want grpc server to listen on \"port\": 8082, // port part of the address on which you'd want grpc server to listen on \"ssl\": { \"enable\": false, // enables or disabled ssl, if disabled credentials will be created using grpc.ServerCredentials.createInsecure() \"cert\": \"location/to/server.cert\", // if enable=true, required config for .cert file \"key\": \"location/to/server/key\", // if enable=true, required config for .key file \"rootCert\": \"location/to/rootCert\" // Optionally, provide location to root cert }, \"mocksDir\": \"./grpcMocks\", // location of the mocks folder \"monitoring\": { \"enable\": true, // enables or disables monitoring \"port\": 40000 // required port for monitoring server } } Folder Structure The way you organize your directories inside the mocksDir, determine how your endpoints will be available. Assuming that you have configured your mocksDir as ./grpcMocks, the folder structure would follow the pattern as shown below. Let's take a look at this proto file syntax = \"proto3\"; package foo.todoPackage; import \"./todoEnum.proto\"; service TodoService{ rpc readTodo(Empty) returns (Todos); rpc readTodoStream(Empty) returns (stream Todo); rpc createTodoStream(stream Todo) returns (Todos); rpc createTodoBidiStream(stream Todo) returns (stream Todo); } The expected mock file path for each required methods would be: ./grpcMocks/foo/todoPackage/readTodo.mock ./grpcMocks/foo/todoPackage/readTodoStream.mock ./grpcMocks/foo/todoPackage/createTodoStream.mock ./grpcMocks/foo/todoPackage/createTodoBidiStream.mock Camouflage GRPC Helpers capture Helper Usage: {{capture from='metadata' key='firstName'}} - Pretty self-explanatory, but if you want to capture some data from the request metadata, you can do so by providing the required key. {{capture from='request' using=\"jsonpath\" selector='$.title'}} - To capture values from the actual request, your options are either using='regex' or using='jsonpath' . Selector will change accordingly. What data to put in .mock files Unary Response A typical unary response mock file would look like following snippet { \"id\": {{num_between lower=100 upper=500}}, \"title\": \"something\", \"metadata\": { \"headers\": { \"random\": \"{{random}}\" }, \"trailers\": { \"now\": \"{{now format='epoch'}}\", \"random\": \"{{random}}\" } }, \"delay\": 2000 } You only need to provide the a json object matching your expected response. In our example, let's say we are creating a mock for createBlog unary method which return a Blog as shown below syntax = \"proto3\"; package blogPackage; message Blog { int32 id = 1; string title = 2; } service BlogService{ rpc createBlog(Blog) returns (Blog); } Corresponding to our Blog schema as per the proto file, we are responding with an random integer between 100-500 using num_between helper. And a random string as title using random helper. Optionally, you can also send metadata, i.e. headers or trailers or both, as shown in the example above. And finally, and optionally, you can simulate a delay of 2 seconds, by including delay: 2000 field. And you might already know by now, you can make the delay random by using the num_between helper. Server Side Streaming Response Mock file for server side streaming response would be mostly similar to unary, except for one distinction. Since we are streaming a response back to client, you'll be providing multiple responses. You can do so by separating each response by a delimiter, i.e. \"====\" (four equals). Other than that, as you would in unary response, metadata.headers, metadata.trailers and delay are optional properties { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } ==== { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } ==== { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } ==== { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } Client Side Streaming Response Client streaming and unary responses are identical. { \"todos\": [ { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" }, { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" }, { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" } ], \"metadata\": { \"trailers\":{ \"key\": \"value\" } }, \"delay\": {{num_between lower=500 upper=600}} } Bidi Streaming Response Bidi streaming supported currently by Camouflage is like ping-pong in nature. For each request you stream to the server, you get one response back. Bidi streaming responses differ from the other responses. Your mockfile would include a required object data . This is what Camouflage will respond back for each of your requests. You can include an optional end object, which would be sent when you end the client side stream. This is an optional object, in absence of which, Camouflage will simply end the server side stream without any response. { \"data\": { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" }, \"end\": { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" } } Request matching Request matching in Camouflage grpc module can be done with a combination of helpers like if , unless and is along with capture helper. GRPC capture helper has access to request and metadata objects from your requests. Usage can be found in the helper section above Note Structure of request object might vary depending on the calls you are making. For example: Unary : In this case, request object is what you would expect it to be. The object you send from the client, as is. Server Side Streaming : Since you make one call from client, and recieve n streams in response as defined in your mock file, same request object is available for each of your responses. Client Side Streaming : All of your request objects are stored in an array, and this array of objects (instead of an object), is made available to your response Bidi Streaming : In this case, request object that you send from the client, is available for each of streams. However the end object that you create, would have access to the array of all request objects sent.","title":"GRPC"},{"location":"grpc/#grpc","text":"GRPC module of Camouflage lets you mock your backends based on grpc protocols. You can create a Camouflage grpc object from CamouflageGrpc class and configure it to serve mocks for your incoming requests. Start by installing required dependencies npx jsr add @camouflage/grpc You can create the Camouflage object without any parameters, and load the required options as needed import CamouflageGrpc from \"@camouflage/grpc\"; import * as protoloader from \"@grpc/proto-loader\"; import * as grpc from \"@grpc/grpc-js\"; const camouflageGrpc = new CamouflageGrpc(); camouflageGrpc.loadConfigFromJson(\"./config_grpc.json\"); //...add your services camouflageGrpc.start(); Or you can create the Camouflage object with the options import CamouflageGrpc, { CamouflageGrpcConfig } from \"@camouflage/grpc\"; const config = {}; const camouflageGrpc = new CamouflageGrpc(config); camouflageGrpc.start();","title":"GRPC"},{"location":"grpc/#available-methods","text":"","title":"Available methods"},{"location":"grpc/#loadconfigfromjson-configfilepath-string-void","text":"While you can include your config as part of your code and ensure the types yourself, you may at times want to maintain the configuration for your Camouflage server separate from the application code. This is usually a good practice from maintainability point of view, or even practical if you want to maintain multiple config files for different usecases. loadConfigFromJson lets you load a config via a .json file. You don't need to worry about validating your config file, Camouflage takes care of validating your config and prints relevant errors which help you fix your config files, if you miss something.","title":"loadConfigFromJson = (configFilePath: string): void"},{"location":"grpc/#gethandlers-camouflagegrpchandler-undefined","text":"Camouflage provides some ready to use handlers which you can use to load your services/methods into the Camouflage grpc servers. Depending on the type of method your mocks require, you can use one of the following: unaryHandler serverSideStreamingHandler clientSideStreamingHandler bidiStreamingHandler","title":"getHandlers = (): CamouflageGrpcHandler | undefined"},{"location":"grpc/#gethelpers-helpers","text":"When you create a CamouflageGrpc object, it automatically creates an instance of helpers. You can use getHelpers() to get a reference to this helpers object. This is useful when you want add custom helpers that are specific to your requirements. import Helpers from \"@camouflage/helpers\"; const helpers = camouflageGrpc.getHelpers(); helpers.addHelper(\"ping\", (context) => { return \"pong\"; }); camouflageGrpc.start(); You can take a look at how inbuilt helpers have been created, in case you want to understand how custom helpers can be created. Refer to the helper source code","title":"getHelpers = (): Helpers"},{"location":"grpc/#addservice-service-grpcservicedefinition-implementation-grpcuntypedserviceimplementation-void","text":"camouflageGrpc.addService is wrapper on @grpc/grpc-js addService method. It allows you to load your proto package definitions/services/methods into Camouflage's grpc server. In the following example we load the blog.proto definition into a grpcObject and use it to provide implementation of the createBlog and listBlogs methods required by the proto definition import CamouflageGrpc, { CamouflageGrpcHandler } from \"@camouflage/grpc\"; import * as protoloader from \"@grpc/proto-loader\"; import * as grpc from \"@grpc/grpc-js\"; const camouflageGrpc = new CamouflageGrpc(); camouflageGrpc.loadConfigFromJson(\"./config_grpc.json\"); const handlers = camouflageGrpc.getHandlers(); const blogPackageDef = protoloader.loadSync(\"./blog.proto\", {}); const blogGrpcObject = grpc.loadPackageDefinition(blogPackageDef); const blogPackage = blogGrpcObject.blogPackage; if (handlers) { camouflageGrpc.addService(blogPackage.BlogService.service, { createBlog: handlers.unaryHandler, listBlogs: handlers.unaryHandler, }); } camouflageGrpc.start(); Here we are using Camouflage's unaryHandler as the implementation of the required methods, but you might as well write your own implementation, making it easier to mock only the required methods instead of everything.","title":"addService = (service: grpc.ServiceDefinition, implementation: grpc.UntypedServiceImplementation): void"},{"location":"grpc/#start-async-promise","text":"Self explanatory. Starts the Camouflage grpc server.","title":"start = async (): Promise"},{"location":"grpc/#stop-async-promise","text":"Self explanatory. Stops the Camouflage grpc server.","title":"stop = async (): Promise"},{"location":"grpc/#hooks","text":"Note COMING SOON","title":"Hooks"},{"location":"grpc/#camouflage-grpc-configuration","text":"You can provide following configuration options in your config.json file and load it to Camouflage before you start the server { \"log\": { \"enable\": true, // enables or disables the logs \"level\": \"trace\" // // if enable=true, sets the log level. Available options are \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\" }, \"host\": \"0.0.0.0\", // host part of the address on which you'd want grpc server to listen on \"port\": 8082, // port part of the address on which you'd want grpc server to listen on \"ssl\": { \"enable\": false, // enables or disabled ssl, if disabled credentials will be created using grpc.ServerCredentials.createInsecure() \"cert\": \"location/to/server.cert\", // if enable=true, required config for .cert file \"key\": \"location/to/server/key\", // if enable=true, required config for .key file \"rootCert\": \"location/to/rootCert\" // Optionally, provide location to root cert }, \"mocksDir\": \"./grpcMocks\", // location of the mocks folder \"monitoring\": { \"enable\": true, // enables or disables monitoring \"port\": 40000 // required port for monitoring server } }","title":"Camouflage GRPC Configuration"},{"location":"grpc/#folder-structure","text":"The way you organize your directories inside the mocksDir, determine how your endpoints will be available. Assuming that you have configured your mocksDir as ./grpcMocks, the folder structure would follow the pattern as shown below. Let's take a look at this proto file syntax = \"proto3\"; package foo.todoPackage; import \"./todoEnum.proto\"; service TodoService{ rpc readTodo(Empty) returns (Todos); rpc readTodoStream(Empty) returns (stream Todo); rpc createTodoStream(stream Todo) returns (Todos); rpc createTodoBidiStream(stream Todo) returns (stream Todo); } The expected mock file path for each required methods would be: ./grpcMocks/foo/todoPackage/readTodo.mock ./grpcMocks/foo/todoPackage/readTodoStream.mock ./grpcMocks/foo/todoPackage/createTodoStream.mock ./grpcMocks/foo/todoPackage/createTodoBidiStream.mock","title":"Folder Structure"},{"location":"grpc/#camouflage-grpc-helpers","text":"","title":"Camouflage GRPC Helpers"},{"location":"grpc/#capture-helper","text":"Usage: {{capture from='metadata' key='firstName'}} - Pretty self-explanatory, but if you want to capture some data from the request metadata, you can do so by providing the required key. {{capture from='request' using=\"jsonpath\" selector='$.title'}} - To capture values from the actual request, your options are either using='regex' or using='jsonpath' . Selector will change accordingly.","title":"capture Helper"},{"location":"grpc/#what-data-to-put-in-mock-files","text":"","title":"What data to put in .mock files"},{"location":"grpc/#unary-response","text":"A typical unary response mock file would look like following snippet { \"id\": {{num_between lower=100 upper=500}}, \"title\": \"something\", \"metadata\": { \"headers\": { \"random\": \"{{random}}\" }, \"trailers\": { \"now\": \"{{now format='epoch'}}\", \"random\": \"{{random}}\" } }, \"delay\": 2000 } You only need to provide the a json object matching your expected response. In our example, let's say we are creating a mock for createBlog unary method which return a Blog as shown below syntax = \"proto3\"; package blogPackage; message Blog { int32 id = 1; string title = 2; } service BlogService{ rpc createBlog(Blog) returns (Blog); } Corresponding to our Blog schema as per the proto file, we are responding with an random integer between 100-500 using num_between helper. And a random string as title using random helper. Optionally, you can also send metadata, i.e. headers or trailers or both, as shown in the example above. And finally, and optionally, you can simulate a delay of 2 seconds, by including delay: 2000 field. And you might already know by now, you can make the delay random by using the num_between helper.","title":"Unary Response"},{"location":"grpc/#server-side-streaming-response","text":"Mock file for server side streaming response would be mostly similar to unary, except for one distinction. Since we are streaming a response back to client, you'll be providing multiple responses. You can do so by separating each response by a delimiter, i.e. \"====\" (four equals). Other than that, as you would in unary response, metadata.headers, metadata.trailers and delay are optional properties { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } ==== { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } ==== { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} } ==== { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\", \"delay\": {{num_between lower=500 upper=600}} }","title":"Server Side Streaming Response"},{"location":"grpc/#client-side-streaming-response","text":"Client streaming and unary responses are identical. { \"todos\": [ { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" }, { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" }, { \"id\": \"{{randomValue type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" } ], \"metadata\": { \"trailers\":{ \"key\": \"value\" } }, \"delay\": {{num_between lower=500 upper=600}} }","title":"Client Side Streaming Response"},{"location":"grpc/#bidi-streaming-response","text":"Bidi streaming supported currently by Camouflage is like ping-pong in nature. For each request you stream to the server, you get one response back. Bidi streaming responses differ from the other responses. Your mockfile would include a required object data . This is what Camouflage will respond back for each of your requests. You can include an optional end object, which would be sent when you end the client side stream. This is an optional object, in absence of which, Camouflage will simply end the server side stream without any response. { \"data\": { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" }, \"end\": { \"id\": \"{{random type='UUID'}}\", \"text\": \"{{random type='ALPHABETIC' length='100'}}\" } }","title":"Bidi Streaming Response"},{"location":"grpc/#request-matching","text":"Request matching in Camouflage grpc module can be done with a combination of helpers like if , unless and is along with capture helper. GRPC capture helper has access to request and metadata objects from your requests. Usage can be found in the helper section above Note Structure of request object might vary depending on the calls you are making. For example: Unary : In this case, request object is what you would expect it to be. The object you send from the client, as is. Server Side Streaming : Since you make one call from client, and recieve n streams in response as defined in your mock file, same request object is available for each of your responses. Client Side Streaming : All of your request objects are stored in an array, and this array of objects (instead of an object), is made available to your response Bidi Streaming : In this case, request object that you send from the client, is available for each of streams. However the end object that you create, would have access to the array of all request objects sent.","title":"Request matching"},{"location":"helpers/","text":"Helpers Camouflage uses handlebars to help you generate dynamic responses if needed. Read more about handlebars here . You can use all the helpers provided by handlebars itself, for example, if , unless , each , and with . Camouflage also provides some additional helpers to make some repetitive tasks easy. array Helper Usage: {{array source='Apple,Banana,Mango,Kiwi' delimiter=','}} : Generate an array from a source using given delimiter. assign Helper Usage: Assign helper can be used to assign a value to a variable, by specifying a name value pair. This can be useful specially when using capture helper using regex and jsonpath selectors. Since running a regex or jsonpath operation is an expensive task, assign helper can be used to capture a value once, store it in a variable and use throughout the mock file. Aesthetically, it also improves readability of the mock file which otherwise would contain long illegible regular expressions repeated throughout the mock file. Following example shows the usage of a complex combination of helpers, i.e. assign, array, concat, and code. {{assign name='fruits' value=(array source=(concat 'Apple' 'Kiwi' 'Oranges' delimiter='-') delimiter='-')}} {{#each fruits as |fruit|}}{{#if @last}}{{fruit}}{{else}}{{fruit}}-{{/if}}{{/each}} Explanation: concat : We are using concat to make a hyphenated string out of 3 seperate string values. array : Then we are making an array by splitting the hyphenated string using the hyphen delimiter. Because why not? assign : Next, we assign this monstrous redundancy to a variable fruits each : Next use the helper each to loop over the fruits array. if : Finally, we use if helper, to make a beautiful string. We concatenate the fruits with a hyphen (if the current fruit is not the last item in the array). Phew, that was quite a journey. We started with 'Apple-Kiwi-Oranges' and we ended it with 'Apple-Kiwi-Oranges'....wait a minute! concat Helper Usage: Concatenates multiple strings together, (static or dynamic), to form a single string. Example: {{concat 'Camouflage ' 'is ' 'easy!!'}} results in Camouflage is easy . You can also pass in a delimiter, i.e. {{concat '1' '22' '333' delimiter='-'}} will result in 1-22-333 csv helper Usage: CSV Helper allows you to provide a data source as an input along with several combinations of selection policies With a key and value : Specify the column name with key and the value you want to search with value . CSV helper returns the first row of the csv file where the value matches the row value in the specified column. Random : Omitting key and value altogether and specifying random=true will fetch you one row at random. All : Specifying all=true , fetches you the entire CSV file, do what you will with the data. Note All combinations of the policies return a JSON Array import Helper Usage: Import helpers lets you store your reusable templates in shared files, which can then be imported into other files. Example: You can create a Camouflage mock file which would contain the response for the request GET /hello/world HTTP/1.1 200 OK Content-Type: application/json { \"now\": \"{{import path=\"/User/john.doe/uselessButReusableNow.mock\"}}\" } Here you are importing the file uselessButResuableNow.mock , Camouflage helper will replace the import with the contents of your imported file. You can create the reusable file as {{now format='yyyy-MM-dd'}} This seems trivial and of no use but think bigger. Your mock file contains not just one but several responses and you select one of them based on a certain condition. You can break down your mocks into several files and import them as needed, making it easier to maintain. inject Helper Time for the forbidden fruit! The security vulnerability. Everything you have been taught not to do. Inject helper allows you replace the hard coded values in your mock files with a javascript code, when you still want to use Camouflage's response builder but you want control over one or two fields. Example: { \"phone\": {{#inject}}(()=>{ return Math.floor(1000000000 + Math.random() * 9000000000); })();{{/inject}} } This translates to a random 10 digit number. Is it a phone number? Is it not? Who knows! Caution inject helper is not enabled by default. If you want to use inject helper, you'd have to enable it when you are creating the helper object. const helpers = new Helpers(true) // setting injectionAllowed = true is Helper Credits: danharper/Handlebars-Helpers Usage: is helper can be considered as an extension of if which allows you to evaluate conditions that are lacking in inbuilt helper. is can be used in following three ways: With one argument: is acts exactly like if {{#is x}} ... {{else}} ... {{/is}} With two arguments: is compares the two are equal (a non-strict, == comparison, so 5 == '5' is true) {{#is x y}} ... {{else}} ... {{/is}} With three arguments: the second argument becomes the comparator. {{#is x \"not\" y}} ... {{else}} ... {{/is}} {{#is 5 \">=\" 2}} ... {{else}} ... {{/is}} Accepted operators are: == (same as not providing a comparator) != not (alias for !=) === !== > >= < <= in (to check if a value exists in an array. ex: {{#is 'John' in (capture from='body' using='jsonpath' selector='$.names')}}) now Helper Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? We use luxon to handle date/time, you can provide any format that's supported by luxon. Read more here . {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset to specify the delta for your desired date from the current date. num_between Helper Usage: {{num_between lower=500 upper=600}} : Generate a random number between two values. {{num_between lower=500 upper=600 lognormal=true}} : Generate random numbers on a bell curve centered between two values. random Helper Usage: {{random}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{random type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{random type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{random type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string.","title":"Helpers"},{"location":"helpers/#helpers","text":"Camouflage uses handlebars to help you generate dynamic responses if needed. Read more about handlebars here . You can use all the helpers provided by handlebars itself, for example, if , unless , each , and with . Camouflage also provides some additional helpers to make some repetitive tasks easy.","title":"Helpers"},{"location":"helpers/#array-helper","text":"Usage: {{array source='Apple,Banana,Mango,Kiwi' delimiter=','}} : Generate an array from a source using given delimiter.","title":"array Helper"},{"location":"helpers/#assign-helper","text":"Usage: Assign helper can be used to assign a value to a variable, by specifying a name value pair. This can be useful specially when using capture helper using regex and jsonpath selectors. Since running a regex or jsonpath operation is an expensive task, assign helper can be used to capture a value once, store it in a variable and use throughout the mock file. Aesthetically, it also improves readability of the mock file which otherwise would contain long illegible regular expressions repeated throughout the mock file. Following example shows the usage of a complex combination of helpers, i.e. assign, array, concat, and code. {{assign name='fruits' value=(array source=(concat 'Apple' 'Kiwi' 'Oranges' delimiter='-') delimiter='-')}} {{#each fruits as |fruit|}}{{#if @last}}{{fruit}}{{else}}{{fruit}}-{{/if}}{{/each}} Explanation: concat : We are using concat to make a hyphenated string out of 3 seperate string values. array : Then we are making an array by splitting the hyphenated string using the hyphen delimiter. Because why not? assign : Next, we assign this monstrous redundancy to a variable fruits each : Next use the helper each to loop over the fruits array. if : Finally, we use if helper, to make a beautiful string. We concatenate the fruits with a hyphen (if the current fruit is not the last item in the array). Phew, that was quite a journey. We started with 'Apple-Kiwi-Oranges' and we ended it with 'Apple-Kiwi-Oranges'....wait a minute!","title":"assign Helper"},{"location":"helpers/#concat-helper","text":"Usage: Concatenates multiple strings together, (static or dynamic), to form a single string. Example: {{concat 'Camouflage ' 'is ' 'easy!!'}} results in Camouflage is easy . You can also pass in a delimiter, i.e. {{concat '1' '22' '333' delimiter='-'}} will result in 1-22-333","title":"concat Helper"},{"location":"helpers/#csv-helper","text":"Usage: CSV Helper allows you to provide a data source as an input along with several combinations of selection policies With a key and value : Specify the column name with key and the value you want to search with value . CSV helper returns the first row of the csv file where the value matches the row value in the specified column. Random : Omitting key and value altogether and specifying random=true will fetch you one row at random. All : Specifying all=true , fetches you the entire CSV file, do what you will with the data. Note All combinations of the policies return a JSON Array","title":"csv helper"},{"location":"helpers/#import-helper","text":"Usage: Import helpers lets you store your reusable templates in shared files, which can then be imported into other files. Example: You can create a Camouflage mock file which would contain the response for the request GET /hello/world HTTP/1.1 200 OK Content-Type: application/json { \"now\": \"{{import path=\"/User/john.doe/uselessButReusableNow.mock\"}}\" } Here you are importing the file uselessButResuableNow.mock , Camouflage helper will replace the import with the contents of your imported file. You can create the reusable file as {{now format='yyyy-MM-dd'}} This seems trivial and of no use but think bigger. Your mock file contains not just one but several responses and you select one of them based on a certain condition. You can break down your mocks into several files and import them as needed, making it easier to maintain.","title":"import Helper"},{"location":"helpers/#inject-helper","text":"Time for the forbidden fruit! The security vulnerability. Everything you have been taught not to do. Inject helper allows you replace the hard coded values in your mock files with a javascript code, when you still want to use Camouflage's response builder but you want control over one or two fields. Example: { \"phone\": {{#inject}}(()=>{ return Math.floor(1000000000 + Math.random() * 9000000000); })();{{/inject}} } This translates to a random 10 digit number. Is it a phone number? Is it not? Who knows! Caution inject helper is not enabled by default. If you want to use inject helper, you'd have to enable it when you are creating the helper object. const helpers = new Helpers(true) // setting injectionAllowed = true","title":"inject Helper"},{"location":"helpers/#is-helper","text":"Credits: danharper/Handlebars-Helpers Usage: is helper can be considered as an extension of if which allows you to evaluate conditions that are lacking in inbuilt helper. is can be used in following three ways: With one argument: is acts exactly like if {{#is x}} ... {{else}} ... {{/is}} With two arguments: is compares the two are equal (a non-strict, == comparison, so 5 == '5' is true) {{#is x y}} ... {{else}} ... {{/is}} With three arguments: the second argument becomes the comparator. {{#is x \"not\" y}} ... {{else}} ... {{/is}} {{#is 5 \">=\" 2}} ... {{else}} ... {{/is}} Accepted operators are: == (same as not providing a comparator) != not (alias for !=) === !== > >= < <= in (to check if a value exists in an array. ex: {{#is 'John' in (capture from='body' using='jsonpath' selector='$.names')}})","title":"is Helper"},{"location":"helpers/#now-helper","text":"Usage: {{now}} - Simply using now will give you date in format YYYY-MM-DD hh:mm:ss {{now format='MM/DD/YYYY'}} - Format not to your liking? We use luxon to handle date/time, you can provide any format that's supported by luxon. Read more here . {{now format='epoch'}} - Time since epoch in milliseconds {{now format='unix'}} - Time since epoch in seconds {{now format='MM/DD/YYYY hh:mm:ss' offset='-10 days'}} - Use offset to specify the delta for your desired date from the current date.","title":"now Helper"},{"location":"helpers/#num_between-helper","text":"Usage: {{num_between lower=500 upper=600}} : Generate a random number between two values. {{num_between lower=500 upper=600 lognormal=true}} : Generate random numbers on a bell curve centered between two values.","title":"num_between Helper"},{"location":"helpers/#random-helper","text":"Usage: {{random}} - Simply using randomValue will generate a 16 character alphanumeric string. ex: 9ZeBvHW5viiYuWRa . {{random type='ALPHANUMERIC'}} - You can specify a type as well. Your choices are: 'ALPHANUMERIC', 'ALPHABETIC', 'NUMERIC' and 'UUID'. {{random type='NUMERIC' length=10}} - Don't want a 16 character output? Use length to specify the length. {{random type='ALPHABETIC' uppercase=true}} - Finally, specify uppercase as true to get a, well, uppercase string.","title":"random Helper"},{"location":"http/","text":"HTTP HTTP module of Camouflage lets you mock your backends based on http, https and http2 protocols. You can create a Camouflage http object from CamouflageHttp class and configure it to serve mocks for your incoming requests. Start by installing required dependencies npx jsr add @camouflage/http You can create the Camouflage object without any parameters, and load the required options as needed import CamouflageHttp from \"@camouflage/http\"; const camouflageHttp = new CamouflageHttp(); camouflageHttp.loadConfigFromJson(\"./config.json\"); camouflageHttp.setServerOptions(options); camouflageHttp.setSecureServerOptions(options); camouflageHttp.setupCacheWithOptions(options); camouflageHttp.setupCorsWithOptions(options); camouflageHttp.start(); Or you can create the Camouflage object with the options import CamouflageHttp, { CamouflageHttpConfig } from \"@camouflage/http\"; import type http from \"http\"; import type https from \"https\"; import type apicache from \"apicache\"; import type cors from \"cors\"; const config = {}; const httpOptions = {}; const httpsOptions = {}; const cacheOptions = {}; const corsOptions = {}; const camouflageHttp = new CamouflageHttp(config, httpOptions, httpsOptions, cacheOptions, corsOptions); camouflageHttp.start(); Available methods getHelpers = (): Helpers When you create a CamouflageHttp object, it automatically creates an instance of helpers. You can use getHelpers() to get a reference to this helpers object. This is useful when you want add custom helpers that are specific to your requirements. import Helpers from \"@camouflage/helpers\"; const helpers = camouflageHttp.getHelpers(); helpers.addHelper(\"ping\", (context) => { return \"pong\"; }); camouflageHttp.start(); You can take a look at how inbuilt helpers have been created, in case you want to understand how custom helpers can be created. Refer to the helper source code . loadConfigFromJson(configFilePath: string): void While you can include your config as part of your code and ensure the types yourself, you may at times want to maintain the configuration for your Camouflage server separate from the application code. This is usually a good practice from maintainability point of view, or even practical if you want to maintain multiple config files for different usecases. loadConfigFromJson lets you load a config via a .json file. You don't need to worry about validating your config file, Camouflage takes care of validating your config and prints relevant errors which help you fix your config files, if you miss something. setServerOptionsHttp(options: http.ServerOptions): void Depending on your use case, you might want to set additional options. Use setServerOptionsHttp2 to pass those options to Camouflage server. Read more about the available options in the official documentation setServerOptionsHttps(options: https.ServerOptions): void In case you are creating an https server, you would need to use setServerOptionsHttps to provide the necessary credentials. You can use it to add other available options as well to your https servers. setServerOptionsHttp2(options: spdy.server.ServerOptions): void In case you are creating an http2 server, you would need to use setServerOptionsHttps to provide the necessary credentials. You can use it to add other available options as well to your http2 servers. setupCacheWithOptions(options: apicache.Options): void Camouflage HTTP uses, apicache to configure a cache middleware for your mocks. By default, the cache is saved in memory and you can provide a ttl in seconds via config. However in case you want more control over the options, you can fine tune the settings using setupCacheWithOptions . Following example shows how you can cache with redis instead of in memory. npm i redis import redis from \"redis\"; import type apicache from \"apicache\"; let cacheOptions = { redisClient: redis.createClient(), respectCacheControl: true, statusCodes: { exclude: [401, 403, 404], include: [200], }, // more options }; camouflageHttp.setupCacheWithOptions(cacheOptions); camouflageHttp.start(); You can refer to apicache documentation for more details on the available options and how to configure them. setupCorsWithOptions(corsOptions: cors.CorsOptions): void Camouflage uses cors middleware to configure cors for your mocks. By default, cors is enabled for all origins and methods, however you can control this by providing Camouflage a corsOptions before you start the server. import type cors from \"cors\"; const corsOptions = { origin: [\"http://localhost:3000\", \"http://instrukti.com/\"], methods: \"GET,POST\", }; camouflageHttp.setupCorsWithOptions(corsOptions); camouflageHttp.start(); Read more about available options on cors documentation . setupValidationWithOptions = (validationOpts: OpenApiValidatorOpts): void Allows you to setup validations using an Open API 3 specification. Read more on the usage in the OpenAPI Validation section. setupCompressionWithOptions = (compressionOpts: CompressionOptions): void Allows you to setup compression options provided by compression middleware . Read more on usage in the compression section. addHook = (route: string, event: \"onRequest\" | \"beforeResponse\" | \"afterResponse\", fn: CamouflageHook): void Apart from the Camouflage helpers, ability to create custom helpers, Camouflage allows you to add hooks to specific routes. You can add hooks to listen to certain events and manipulate the request/response as you wish. Available hooks are: onRequest : onRequest hooks are executed as soon as Camouflage recieves the request. You can use onRequest hooks to intercept the incoming request. You can either make some changes to your incoming request object and then let Camouflage run the response builder on the modified request, or bypass the Camouflage response builder entirely and send the response from within the hook itself without refering to any mock files. beforeResponse : beforeResponse hooks are executed right before Camouflage is about to send the response. beforeResponse hooks are useful when you want Camouflage response builder to use the provided mock file to build a response, however you want to modify the response before it's sent. afterResponse : afterResponse hooks are executed once Camouflage has sent the response. afterResponse hooks is useful for logging or other such activities. In the following section, you'll see how we can configure and use these hooks. start(): void Self explanatory. Starts the Camouflage http server. stop(): void Self explanatory. Stops the Camouflage http server. restart(): void Self explanatory. Restarts the Camouflage http server. Hooks onRequest In the following example, we'll see how can we use onRequest hook to intercept the incoming request: camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"onRequest\", (req, res) => { console.log(\"Hello from hook\", req.route.path); // You can do some logging res.set(\"Sent-From\", \"onRequestHook\"); // You can set some headers // You can check some conditions if (req.param.userId === 1) { // If the condition passes, you can choose to bypass Camouflage entirely by sending the response from within the hook res.set(\"Content-Type\", \"application/json\"); const body = { message: \"Sent from onRequestHook\", }; res.status(200).send(JSON.stringify(body)); } // Or you can do nothing and let Camouflage take over after you are done modifying the request/response objects }); beforeResponse Similarily you can use beforeResponse , to intercept and manipulate the responses generated by Camouflage response builder camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"beforeResponse\", (req, res, camouflageResponse) => { if (camouflageResponse) console.log(camouflageResponse); res.set(\"Added-In-Hook\", \"SomeHeader\"); }); afterResponse Finally, you can use afterResponse hooks to measure time or log some messages as shown below let time = 0; let startTime = 0; camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"onRequest\", (req, res) => { startTime = Date.now(); console.log(\"Hello from hook\", req.route.path); }); camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"afterResponse\", (req, res) => { time = Date.now() - startTime; console.log(time); time = 0; startTime = 0; }); Camouflage Http Configuration You can provide following configuration options in your config.json file and load it to Camouflage before you start the server { \"log\": { \"enable\": true, // enables or disables the logs entirely \"level\": \"trace\", // if enable=true, sets the log level. Available options are \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\" \"disableRequestLogs\": true // if not disabled, each incoming request will be logged. }, \"http\": { \"enable\": true, // enables or disables http server \"port\": 8080 // port on which http server would be available }, \"https\": { \"enable\": false, // enables or disables https server \"port\": 8443 // port on which https server would be available }, \"http2\": { \"enable\": false, // enables or disables http2 server \"port\": 9443 // port on which http2 server would be available }, \"monitoring\": true, // if enabled, provides a /monitoring endpoint with some dashboards for monitoring \"cache\": { \"enable\": true, // enables or disables cache \"timeInSeconds\": 5 // if enabled, sets cache ttl to 5 seconds }, \"enableCors\": true, // enables or disables cors \"mocksDir\": \"./mocks\" // location of the directory where your mocks live. } Folder structure The way you organize your directories inside the mocksDir , determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain. We assume that you have configured your mocksDir as ./mocks in following examples GET Request to /hello/world Create a directory ./mocks/hello/world . Create a GET.mock file inside it with your required response. HTTP/1.1 200 OK X-Provided-By: CamouflageHttp Content-Type: application/json { \"hello\": \"world\" } GET Request to /user/:userId/wallet/:walletId Create a directory /user/:userId/wallet/:walletId Create a GET.mock file inside it with your required response HTTP/1.1 200 OK Content-Type: application/json { \"userId\": {{capture from='path' key='userId'}}, \"walletId\": {{capture from='path' key='walletId'}}, \"createdAt\": \"{{now format='epoch'}}\", } Note Notice the use of helpers in the above mock. Alongwith the inbuilt now helper, Camouflage http module provides some additional helpers, capture being one of them. In the following section, you can read more about additional helpers that specific to http module. Similarly you can create PUT.mock, DELETE.mock etc in your intended path as required by your mocked endpoint. Warning If you are coming from the previous version of Camouflage, note that we have dropped support for wildcards i.e. __ / double underscores. They were primarily intended to be used for dynamic path params which are now handled the way express handles them, which makes it more robust and easy to understand. Camouflage HTTP Helpers In addition to the available helpers that come with @camouflage/helpers module, Camouflage http module provides some protocol specific helpers. capture Helper Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if your endpoint looks like /hello/world?firstName=John&lastName=Wick . And your response is {\"message\": \"Hello Wick, John\"} , you can make the response dynamic by formatting your response as { \"message\": \"Hello {{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='cookies' key='mycookie'}} - For cookies, you'd need to specify a key to capture a value. {{capture from='path' key='walletId'}} - For path, you'd need to specify a key to capture a value. {{capture from='headers' key='Authorization'}} - For headers, you'd need to specify a key to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from the request body, your options are either using='regex' or using='jsonpath' . Selector will change accordingly. file Helper Usage: {{file path='/location/of/the/image/or/text/or/any/file'}} : If you want to serve a file as a response, maybe an image, or text file, a pdf document, or any type of supported files, use file helper to do so. Content-Type header is decided automatically based on the file type. An example is shown below: HTTP/1.1 200 OK {{file path=\"./docs/camouflage.png\"}} state Helper Usage: State helper gets the mocked state value using a key send within the cookie header. If no value is found it will use the default context within the block. For example: { \"has_pending_order\": {{#state key='has-pending-order'}}false{{/state}}, \"cart\": {{#state key='cart'}}[ {\"id\": 999, \"name\": \"default prod\"} ]{{/state}} } To set a value just send cookie with a specific prefix. const prefix = \"mocked-state\"; const key = \"has-pending-order\"; setCookie(`${prefix}-has-pending-order`, \"true\"); setCookie(`${prefix}-cart`, '[{id: 1, name: \"prod1\"}, {id: 2, name: \"prod2\"}]'); Usage in Cypress If you use Camouflage with Cypress you could add the following custom command to make life easier. /** * Custom cypress command to set a mocked state */ Cypress.Commands.add(\"setState\", (key, value) => { cy.setCookie(`mocked-state-${key}`, typeof value === \"string\" ? value : JSON.stringify(value)); }); Then in your tests cy.setState(\"has_pending_order\", true); cy.setState(\"cart\", [ { id: 1, name: \"prod1\" }, { id: 2, name: \"prod2\" }, ]); What data to put in .mock files Camouflage expects a raw HTTP Response to be placed in the .mock files. Please refer to this Wikipedia page, if you are not sure what the response looks like. Each mock file can have the HTTP Responses in following manner: One response per .mock file. Multiple responses in one .mock file with conditions defined to help Camouflage decide which response should be sent under what conditions. (Read Handlebars section for more) Multiple responses separated by Camouflage's delimiter i.e. \"====\" (four equals). Camouflage will pick one response at random and send it to the client. An example of this can be found here The data you want in your mock file can be easily fetched using a curl command with -i -X flags as shown in the example below. curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ./mocks/users/:userId , and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } Another, easier, approach to create mocks is by installing the REST Client VS Code Extension and using it to fetch the required data for mocks. Launch VS Code and install \"REST Client\" Extension by Huachao Mao or simply open the link above. Create a .http file in your project to document your actual http endpoints and make the requests. Visit REST Client github repository for more details on usage Line breaks Note Camouflage by default looks for the OS specific line breaks. For example, if you are on MacOS or Unix based systems, the default line break/new line is \\n , whereas on windows it's \\r\\n . This is known to cause issues if your development environment and testing environment are different for Camouflage. For example, if you have created your mock file on a windows machine and uploaded it to a Camouflage server running on linux, your mocks might not work as expected. Or in case your text editor's line break settings do not match your OS default line break, you might not get an expected response. Though Camouflage detects new lines used in the file irrespective of the OS default, you should not face any issues. However, if you face any issues where you are getting a blank response or any unexpected response, please create an issue attaching your log files. REMEMBER TO REMOVE SENSITIVE DATA, IF ANY, FROM YOUR LOGS. Request Matching There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized response. To do so you can utilize the beauty of handlebars. Simply provide an if else condition and you are good to go. Let's understand how to do this in the following example: You expect the user to call the endpoint /hello in two ways. By simple making a GET request to /hello ; Or By adding a query parameter name in the GET request to /hello . i.e. /hello?name=John Based on how the user calls the API, you'd want to send different responses. Let's see how we can achieve the desired result. Start by creating a GET.mock file at the location ./mocks/hello . Paste the following content in the mock file. {{#if request.query.name}} HTTP/1.1 200 OK X-Provided-By: CamouflageHttp Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Provided-By: CamouflageHttp Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}} In the example above, we have provided two responses that Camouflage can pick from, one with greeting: \"Hello World\" , and another with greeting: \"Hello John\" . In the first line of the mock {{#if request.query.name}} , we are checking for the condition, if there exists a query parameter called name . And that's it. If your request is made with the query param name , Camouflage will respond with first response, if not then the 2nd second response is what you get. And the value of name can be anything. We are using capture helper to help us make our response dynamic. Note if and unless helpers are provided by handlebarjs, which don't have comparison capabilities. These helpers only check if the provided value is truthy or falsy. i.e. you can not do something like this: {{#if something = something}} . For comparisons, you'd need to use is helper. See Helpers page for example. Request Matching using headers You can use the approach shown above to perform request matching with query, path params and cookies. Use request.query.name or request.params.name or request.cookies.something as required. However for headers and body, we need to follow a slightly different approach. In the following example, we are using capture helper to capture a specific header value which then can be passed to other helpers like is or if . {{#if (capture from='headers' key='Authorization') }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/if}} If you want to validate a given header against a specific value, the mock file would be as shown below: {{#is (capture from='headers' key='Authorization') 'Basic c2h1YmhlbmR1Om1hZGh1a2Fy' }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/is}} Request model Request object made available by Camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.body request.cookies request.method request.originalUrl request.path request.protocol request.query request.body Refer to Express Documentation for more information on each of these properties. Response Delays You can add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for GET /hello endpoint, contents of your ./mocks/hello/GET.mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}} OpenAPI Conversion If you have access to the OpenAPI specification for the APIs/Endpoints you want to mock, Camouflage supports the conversion via the camoswag utility. To use camoswag , you would need your OpenAPI specification file in either .json or .yaml format. You don't need to install camoswag locally on your machine, you can simply run the script using npx. Run the command: npx camoswag --spec ./swagger.yaml or npx camoswag --spec ./swagger.json . (Replace file location with your spec file location) If you would like to install camoswag locally, you can do so by running the command: npm i -g camoswag . For conversion use, camoswag --spec ./swagger.yaml This would create a new folder with the name camouflage-${current_timestamp} containing the required folder structure and mock files corresponding to each endpoint defined in your spec file. You can either delete or modify the dummy responses placed in the mockfiles as per your expectations. Once you are satisfied with the modifications, you can move the contents of the folder to your original mocksDir of your running Camouflage server. Note that if your spec file doesn't contain a response defined for a given endpoint, camoswag would put the following default response in the mock file. { \"message\": \"More Configuration Needed\" } Caution camoswag currently supports JSON responses only. OpenAPI Validation Camouflage uses express-openapi-validator to enable you to validate your requests/responses against a provided OpenAPI 3 schema. You can configure validation in two ways. Basic Usage: You can enable it via config.json. Add following options to you config: { // Other Camouflage options \"validation\": { \"enable\": true, \"apiSpec\": \"./apiSpec.yaml\", \"validateRequests\": true, \"validateResponses\": true } } Modify the above config as per your requirements, and you are good to go. Advanced Usage: If you want more control over how to configure validation, you can set the supported validation options via the Camouflage method setupValidationWithOptions Enable it via config { // Other Camouflage options \"validation\": { \"enable\": true } } And then configure rest of the options as you wish camouflageHttp.setupValidationWithOptions({ apiSpec: \"./openapi.yaml\", validateRequests: true, validateResponses: true, // Other options }); Compression You can optionally enable the compression options via config.json. Once enabled, compression is applied on all the routes, however you can restrict this behaviour using the setupCompressionWithOptions method and available options Enable compression in config.json { // Other Camouflage options \"compression\": true } Then provide required options function shouldCompress(req, res) { if (req.headers[\"x-no-compression\"]) { // don't compress responses with this request header return false; } // fallback to standard filter function return compression.filter(req, res); } camouflageHttp.setupCompressionWithOptions({ filter: shouldCompress });","title":"HTTP"},{"location":"http/#http","text":"HTTP module of Camouflage lets you mock your backends based on http, https and http2 protocols. You can create a Camouflage http object from CamouflageHttp class and configure it to serve mocks for your incoming requests. Start by installing required dependencies npx jsr add @camouflage/http You can create the Camouflage object without any parameters, and load the required options as needed import CamouflageHttp from \"@camouflage/http\"; const camouflageHttp = new CamouflageHttp(); camouflageHttp.loadConfigFromJson(\"./config.json\"); camouflageHttp.setServerOptions(options); camouflageHttp.setSecureServerOptions(options); camouflageHttp.setupCacheWithOptions(options); camouflageHttp.setupCorsWithOptions(options); camouflageHttp.start(); Or you can create the Camouflage object with the options import CamouflageHttp, { CamouflageHttpConfig } from \"@camouflage/http\"; import type http from \"http\"; import type https from \"https\"; import type apicache from \"apicache\"; import type cors from \"cors\"; const config = {}; const httpOptions = {}; const httpsOptions = {}; const cacheOptions = {}; const corsOptions = {}; const camouflageHttp = new CamouflageHttp(config, httpOptions, httpsOptions, cacheOptions, corsOptions); camouflageHttp.start();","title":"HTTP"},{"location":"http/#available-methods","text":"","title":"Available methods"},{"location":"http/#gethelpers-helpers","text":"When you create a CamouflageHttp object, it automatically creates an instance of helpers. You can use getHelpers() to get a reference to this helpers object. This is useful when you want add custom helpers that are specific to your requirements. import Helpers from \"@camouflage/helpers\"; const helpers = camouflageHttp.getHelpers(); helpers.addHelper(\"ping\", (context) => { return \"pong\"; }); camouflageHttp.start(); You can take a look at how inbuilt helpers have been created, in case you want to understand how custom helpers can be created. Refer to the helper source code .","title":"getHelpers = (): Helpers"},{"location":"http/#loadconfigfromjsonconfigfilepath-string-void","text":"While you can include your config as part of your code and ensure the types yourself, you may at times want to maintain the configuration for your Camouflage server separate from the application code. This is usually a good practice from maintainability point of view, or even practical if you want to maintain multiple config files for different usecases. loadConfigFromJson lets you load a config via a .json file. You don't need to worry about validating your config file, Camouflage takes care of validating your config and prints relevant errors which help you fix your config files, if you miss something.","title":"loadConfigFromJson(configFilePath: string): void"},{"location":"http/#setserveroptionshttpoptions-httpserveroptions-void","text":"Depending on your use case, you might want to set additional options. Use setServerOptionsHttp2 to pass those options to Camouflage server. Read more about the available options in the official documentation","title":"setServerOptionsHttp(options: http.ServerOptions): void"},{"location":"http/#setserveroptionshttpsoptions-httpsserveroptions-void","text":"In case you are creating an https server, you would need to use setServerOptionsHttps to provide the necessary credentials. You can use it to add other available options as well to your https servers.","title":"setServerOptionsHttps(options: https.ServerOptions): void"},{"location":"http/#setserveroptionshttp2options-spdyserverserveroptions-void","text":"In case you are creating an http2 server, you would need to use setServerOptionsHttps to provide the necessary credentials. You can use it to add other available options as well to your http2 servers.","title":"setServerOptionsHttp2(options: spdy.server.ServerOptions): void"},{"location":"http/#setupcachewithoptionsoptions-apicacheoptions-void","text":"Camouflage HTTP uses, apicache to configure a cache middleware for your mocks. By default, the cache is saved in memory and you can provide a ttl in seconds via config. However in case you want more control over the options, you can fine tune the settings using setupCacheWithOptions . Following example shows how you can cache with redis instead of in memory. npm i redis import redis from \"redis\"; import type apicache from \"apicache\"; let cacheOptions = { redisClient: redis.createClient(), respectCacheControl: true, statusCodes: { exclude: [401, 403, 404], include: [200], }, // more options }; camouflageHttp.setupCacheWithOptions(cacheOptions); camouflageHttp.start(); You can refer to apicache documentation for more details on the available options and how to configure them.","title":"setupCacheWithOptions(options: apicache.Options): void"},{"location":"http/#setupcorswithoptionscorsoptions-corscorsoptions-void","text":"Camouflage uses cors middleware to configure cors for your mocks. By default, cors is enabled for all origins and methods, however you can control this by providing Camouflage a corsOptions before you start the server. import type cors from \"cors\"; const corsOptions = { origin: [\"http://localhost:3000\", \"http://instrukti.com/\"], methods: \"GET,POST\", }; camouflageHttp.setupCorsWithOptions(corsOptions); camouflageHttp.start(); Read more about available options on cors documentation .","title":"setupCorsWithOptions(corsOptions: cors.CorsOptions): void"},{"location":"http/#setupvalidationwithoptions-validationopts-openapivalidatoropts-void","text":"Allows you to setup validations using an Open API 3 specification. Read more on the usage in the OpenAPI Validation section.","title":"setupValidationWithOptions = (validationOpts: OpenApiValidatorOpts): void"},{"location":"http/#setupcompressionwithoptions-compressionopts-compressionoptions-void","text":"Allows you to setup compression options provided by compression middleware . Read more on usage in the compression section.","title":"setupCompressionWithOptions = (compressionOpts: CompressionOptions): void"},{"location":"http/#addhook-route-string-event-onrequest-beforeresponse-afterresponse-fn-camouflagehook-void","text":"Apart from the Camouflage helpers, ability to create custom helpers, Camouflage allows you to add hooks to specific routes. You can add hooks to listen to certain events and manipulate the request/response as you wish. Available hooks are: onRequest : onRequest hooks are executed as soon as Camouflage recieves the request. You can use onRequest hooks to intercept the incoming request. You can either make some changes to your incoming request object and then let Camouflage run the response builder on the modified request, or bypass the Camouflage response builder entirely and send the response from within the hook itself without refering to any mock files. beforeResponse : beforeResponse hooks are executed right before Camouflage is about to send the response. beforeResponse hooks are useful when you want Camouflage response builder to use the provided mock file to build a response, however you want to modify the response before it's sent. afterResponse : afterResponse hooks are executed once Camouflage has sent the response. afterResponse hooks is useful for logging or other such activities. In the following section, you'll see how we can configure and use these hooks.","title":"addHook = (route: string, event: \"onRequest\" | \"beforeResponse\" | \"afterResponse\", fn: CamouflageHook): void"},{"location":"http/#start-void","text":"Self explanatory. Starts the Camouflage http server.","title":"start(): void"},{"location":"http/#stop-void","text":"Self explanatory. Stops the Camouflage http server.","title":"stop(): void"},{"location":"http/#restart-void","text":"Self explanatory. Restarts the Camouflage http server.","title":"restart(): void"},{"location":"http/#hooks","text":"","title":"Hooks"},{"location":"http/#onrequest","text":"In the following example, we'll see how can we use onRequest hook to intercept the incoming request: camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"onRequest\", (req, res) => { console.log(\"Hello from hook\", req.route.path); // You can do some logging res.set(\"Sent-From\", \"onRequestHook\"); // You can set some headers // You can check some conditions if (req.param.userId === 1) { // If the condition passes, you can choose to bypass Camouflage entirely by sending the response from within the hook res.set(\"Content-Type\", \"application/json\"); const body = { message: \"Sent from onRequestHook\", }; res.status(200).send(JSON.stringify(body)); } // Or you can do nothing and let Camouflage take over after you are done modifying the request/response objects });","title":"onRequest"},{"location":"http/#beforeresponse","text":"Similarily you can use beforeResponse , to intercept and manipulate the responses generated by Camouflage response builder camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"beforeResponse\", (req, res, camouflageResponse) => { if (camouflageResponse) console.log(camouflageResponse); res.set(\"Added-In-Hook\", \"SomeHeader\"); });","title":"beforeResponse"},{"location":"http/#afterresponse","text":"Finally, you can use afterResponse hooks to measure time or log some messages as shown below let time = 0; let startTime = 0; camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"onRequest\", (req, res) => { startTime = Date.now(); console.log(\"Hello from hook\", req.route.path); }); camouflageHttp.addHook(\"/user/:userId/wallet/:walletId\", \"afterResponse\", (req, res) => { time = Date.now() - startTime; console.log(time); time = 0; startTime = 0; });","title":"afterResponse"},{"location":"http/#camouflage-http-configuration","text":"You can provide following configuration options in your config.json file and load it to Camouflage before you start the server { \"log\": { \"enable\": true, // enables or disables the logs entirely \"level\": \"trace\", // if enable=true, sets the log level. Available options are \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\" \"disableRequestLogs\": true // if not disabled, each incoming request will be logged. }, \"http\": { \"enable\": true, // enables or disables http server \"port\": 8080 // port on which http server would be available }, \"https\": { \"enable\": false, // enables or disables https server \"port\": 8443 // port on which https server would be available }, \"http2\": { \"enable\": false, // enables or disables http2 server \"port\": 9443 // port on which http2 server would be available }, \"monitoring\": true, // if enabled, provides a /monitoring endpoint with some dashboards for monitoring \"cache\": { \"enable\": true, // enables or disables cache \"timeInSeconds\": 5 // if enabled, sets cache ttl to 5 seconds }, \"enableCors\": true, // enables or disables cors \"mocksDir\": \"./mocks\" // location of the directory where your mocks live. }","title":"Camouflage Http Configuration"},{"location":"http/#folder-structure","text":"The way you organize your directories inside the mocksDir , determine how your endpoints will be available. Following examples will help you understand the folder structure you need to maintain. We assume that you have configured your mocksDir as ./mocks in following examples","title":"Folder structure"},{"location":"http/#get-request-to-helloworld","text":"Create a directory ./mocks/hello/world . Create a GET.mock file inside it with your required response. HTTP/1.1 200 OK X-Provided-By: CamouflageHttp Content-Type: application/json { \"hello\": \"world\" }","title":"GET Request to /hello/world"},{"location":"http/#get-request-to-useruseridwalletwalletid","text":"Create a directory /user/:userId/wallet/:walletId Create a GET.mock file inside it with your required response HTTP/1.1 200 OK Content-Type: application/json { \"userId\": {{capture from='path' key='userId'}}, \"walletId\": {{capture from='path' key='walletId'}}, \"createdAt\": \"{{now format='epoch'}}\", } Note Notice the use of helpers in the above mock. Alongwith the inbuilt now helper, Camouflage http module provides some additional helpers, capture being one of them. In the following section, you can read more about additional helpers that specific to http module. Similarly you can create PUT.mock, DELETE.mock etc in your intended path as required by your mocked endpoint. Warning If you are coming from the previous version of Camouflage, note that we have dropped support for wildcards i.e. __ / double underscores. They were primarily intended to be used for dynamic path params which are now handled the way express handles them, which makes it more robust and easy to understand.","title":"GET Request to /user/:userId/wallet/:walletId"},{"location":"http/#camouflage-http-helpers","text":"In addition to the available helpers that come with @camouflage/helpers module, Camouflage http module provides some protocol specific helpers.","title":"Camouflage HTTP Helpers"},{"location":"http/#capture-helper","text":"Usage: {{capture from='query' key='firstName'}} - Pretty self-explanatory, but if your endpoint looks like /hello/world?firstName=John&lastName=Wick . And your response is {\"message\": \"Hello Wick, John\"} , you can make the response dynamic by formatting your response as { \"message\": \"Hello {{capture from='query' key='lastName'}}, {{capture from='query' key='firstName'}}\" } {{capture from='cookies' key='mycookie'}} - For cookies, you'd need to specify a key to capture a value. {{capture from='path' key='walletId'}} - For path, you'd need to specify a key to capture a value. {{capture from='headers' key='Authorization'}} - For headers, you'd need to specify a key to capture a value. {{capture from='body' using='jsonpath' selector='$.lastName'}} - To capture values from the request body, your options are either using='regex' or using='jsonpath' . Selector will change accordingly.","title":"capture Helper"},{"location":"http/#file-helper","text":"Usage: {{file path='/location/of/the/image/or/text/or/any/file'}} : If you want to serve a file as a response, maybe an image, or text file, a pdf document, or any type of supported files, use file helper to do so. Content-Type header is decided automatically based on the file type. An example is shown below: HTTP/1.1 200 OK {{file path=\"./docs/camouflage.png\"}}","title":"file Helper"},{"location":"http/#state-helper","text":"Usage: State helper gets the mocked state value using a key send within the cookie header. If no value is found it will use the default context within the block. For example: { \"has_pending_order\": {{#state key='has-pending-order'}}false{{/state}}, \"cart\": {{#state key='cart'}}[ {\"id\": 999, \"name\": \"default prod\"} ]{{/state}} } To set a value just send cookie with a specific prefix. const prefix = \"mocked-state\"; const key = \"has-pending-order\"; setCookie(`${prefix}-has-pending-order`, \"true\"); setCookie(`${prefix}-cart`, '[{id: 1, name: \"prod1\"}, {id: 2, name: \"prod2\"}]');","title":"state Helper"},{"location":"http/#usage-in-cypress","text":"If you use Camouflage with Cypress you could add the following custom command to make life easier. /** * Custom cypress command to set a mocked state */ Cypress.Commands.add(\"setState\", (key, value) => { cy.setCookie(`mocked-state-${key}`, typeof value === \"string\" ? value : JSON.stringify(value)); }); Then in your tests cy.setState(\"has_pending_order\", true); cy.setState(\"cart\", [ { id: 1, name: \"prod1\" }, { id: 2, name: \"prod2\" }, ]);","title":"Usage in Cypress"},{"location":"http/#what-data-to-put-in-mock-files","text":"Camouflage expects a raw HTTP Response to be placed in the .mock files. Please refer to this Wikipedia page, if you are not sure what the response looks like. Each mock file can have the HTTP Responses in following manner: One response per .mock file. Multiple responses in one .mock file with conditions defined to help Camouflage decide which response should be sent under what conditions. (Read Handlebars section for more) Multiple responses separated by Camouflage's delimiter i.e. \"====\" (four equals). Camouflage will pick one response at random and send it to the client. An example of this can be found here The data you want in your mock file can be easily fetched using a curl command with -i -X flags as shown in the example below. curl -i -X GET https://jsonplaceholder.typicode.com/users/1 > GET.mock Running this command, gives you a GET.mock file with following content. Modify it according to your requirement and place it in the location ./mocks/users/:userId , and you have successfully mocked jsonplaceholder API. HTTP/1.1 200 OK date: Sat, 17 Apr 2021 05:21:51 GMT content-type: application/json; charset=utf-8 content-length: 509 set-cookie: __cfduid=ddf6b687a745fea6ab343400b5dfe9f141618636911; expires=Mon, 17-May-21 05:21:51 GMT; path=/; domain=.typicode.com; HttpOnly; SameSite=Lax x-powered-by: Express x-ratelimit-limit: 1000 x-ratelimit-remaining: 998 x-ratelimit-reset: 1612952731 vary: Origin, Accept-Encoding access-control-allow-credentials: true cache-control: max-age=43200 pragma: no-cache expires: -1 x-content-type-options: nosniff etag: W/\"1fd-+2Y3G3w049iSZtw5t1mzSnunngE\" via: 1.1 vegur cf-cache-status: HIT age: 14578 accept-ranges: bytes cf-request-id: 097fe04d2c000019d97db7d000000001 expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report?s=%2FkpNonG0wnuykR5xxlGXKBUxm5DN%2BI1PpQ0ytmiw931XaIVBNqZMJLEr0%2F3kDTrOhbX%2FCCPZtI4iuU3V%2F07wO5uwqov0d4c12%2Fcdpiz7TIFqzGkr7DwUrzt40CLH\"}],\"max_age\":604800,\"group\":\"cf-nel\"} nel: {\"max_age\":604800,\"report_to\":\"cf-nel\"} server: cloudflare cf-ray: 6413365b7e9919d9-SIN alt-svc: h3-27=\":443\"; ma=86400, h3-28=\":443\"; ma=86400, h3-29=\":443\"; ma=86400 { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"Romaguera-Crona\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } Another, easier, approach to create mocks is by installing the REST Client VS Code Extension and using it to fetch the required data for mocks. Launch VS Code and install \"REST Client\" Extension by Huachao Mao or simply open the link above. Create a .http file in your project to document your actual http endpoints and make the requests. Visit REST Client github repository for more details on usage","title":"What data to put in .mock files"},{"location":"http/#line-breaks","text":"Note Camouflage by default looks for the OS specific line breaks. For example, if you are on MacOS or Unix based systems, the default line break/new line is \\n , whereas on windows it's \\r\\n . This is known to cause issues if your development environment and testing environment are different for Camouflage. For example, if you have created your mock file on a windows machine and uploaded it to a Camouflage server running on linux, your mocks might not work as expected. Or in case your text editor's line break settings do not match your OS default line break, you might not get an expected response. Though Camouflage detects new lines used in the file irrespective of the OS default, you should not face any issues. However, if you face any issues where you are getting a blank response or any unexpected response, please create an issue attaching your log files. REMEMBER TO REMOVE SENSITIVE DATA, IF ANY, FROM YOUR LOGS.","title":"Line breaks"},{"location":"http/#request-matching","text":"There are scenarios when you would need to change your response based on some conditions met by fields on request objects. For example, if the end user passes an Authorization header, you'd want to send a 200 OK response if not you'd want to send a 401 Unauthorized response. To do so you can utilize the beauty of handlebars. Simply provide an if else condition and you are good to go. Let's understand how to do this in the following example: You expect the user to call the endpoint /hello in two ways. By simple making a GET request to /hello ; Or By adding a query parameter name in the GET request to /hello . i.e. /hello?name=John Based on how the user calls the API, you'd want to send different responses. Let's see how we can achieve the desired result. Start by creating a GET.mock file at the location ./mocks/hello . Paste the following content in the mock file. {{#if request.query.name}} HTTP/1.1 200 OK X-Provided-By: CamouflageHttp Content-Type: application/json { \"greeting\": \"Hello {{capture from='query' key='name'}}\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{else}} HTTP/1.1 200 OK X-Provided-By: CamouflageHttp Content-Type: application/json { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } {{/if}} In the example above, we have provided two responses that Camouflage can pick from, one with greeting: \"Hello World\" , and another with greeting: \"Hello John\" . In the first line of the mock {{#if request.query.name}} , we are checking for the condition, if there exists a query parameter called name . And that's it. If your request is made with the query param name , Camouflage will respond with first response, if not then the 2nd second response is what you get. And the value of name can be anything. We are using capture helper to help us make our response dynamic. Note if and unless helpers are provided by handlebarjs, which don't have comparison capabilities. These helpers only check if the provided value is truthy or falsy. i.e. you can not do something like this: {{#if something = something}} . For comparisons, you'd need to use is helper. See Helpers page for example.","title":"Request Matching"},{"location":"http/#request-matching-using-headers","text":"You can use the approach shown above to perform request matching with query, path params and cookies. Use request.query.name or request.params.name or request.cookies.something as required. However for headers and body, we need to follow a slightly different approach. In the following example, we are using capture helper to capture a specific header value which then can be passed to other helpers like is or if . {{#if (capture from='headers' key='Authorization') }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/if}} If you want to validate a given header against a specific value, the mock file would be as shown below: {{#is (capture from='headers' key='Authorization') 'Basic c2h1YmhlbmR1Om1hZGh1a2Fy' }} HTTP/1.1 200 OK Content-Type: application/json { \"response\": \"response if auth header is present.\" } {{else}} HTTP/1.1 401 Unauthorized Content-Type: application/json { \"response\": \"response if no auth header present.\" } {{/is}}","title":"Request Matching using headers"},{"location":"http/#request-model","text":"Request object made available by Camouflage is simply an instance of express request object for a given incoming request. Following are the properties/objects available on the request object which can be used in request matching or to extract information out of the request. request.baseUrl request.body request.cookies request.method request.originalUrl request.path request.protocol request.query request.body Refer to Express Documentation for more information on each of these properties.","title":"Request model"},{"location":"http/#response-delays","text":"You can add a Response-Delay header in raw response placed in your .mock file. For example, if you'd like to simulate a delay of 2 seconds for GET /hello endpoint, contents of your ./mocks/hello/GET.mock file would be as follows: HTTP/1.1 200 OK X-Requested-By: Shubhendu Madhukar Content-Type: application/json Response-Delay: 2000 { \"greeting\": \"Hello World\", \"phone\": {{randomValue length=10 type='NUMERIC'}}, \"dateOfBirth\": \"{{now format='MM/DD/YYYY'}}\", \"test\": \"{{randomValue}}\" } Additionally you can also simulate a dynamic delay using the {{num_between}} handlebar as follows Response-Delay: {{num_between lower=500 upper=600}}","title":"Response Delays"},{"location":"http/#openapi-conversion","text":"If you have access to the OpenAPI specification for the APIs/Endpoints you want to mock, Camouflage supports the conversion via the camoswag utility. To use camoswag , you would need your OpenAPI specification file in either .json or .yaml format. You don't need to install camoswag locally on your machine, you can simply run the script using npx. Run the command: npx camoswag --spec ./swagger.yaml or npx camoswag --spec ./swagger.json . (Replace file location with your spec file location) If you would like to install camoswag locally, you can do so by running the command: npm i -g camoswag . For conversion use, camoswag --spec ./swagger.yaml This would create a new folder with the name camouflage-${current_timestamp} containing the required folder structure and mock files corresponding to each endpoint defined in your spec file. You can either delete or modify the dummy responses placed in the mockfiles as per your expectations. Once you are satisfied with the modifications, you can move the contents of the folder to your original mocksDir of your running Camouflage server. Note that if your spec file doesn't contain a response defined for a given endpoint, camoswag would put the following default response in the mock file. { \"message\": \"More Configuration Needed\" } Caution camoswag currently supports JSON responses only.","title":"OpenAPI Conversion"},{"location":"http/#openapi-validation","text":"Camouflage uses express-openapi-validator to enable you to validate your requests/responses against a provided OpenAPI 3 schema. You can configure validation in two ways. Basic Usage: You can enable it via config.json. Add following options to you config: { // Other Camouflage options \"validation\": { \"enable\": true, \"apiSpec\": \"./apiSpec.yaml\", \"validateRequests\": true, \"validateResponses\": true } } Modify the above config as per your requirements, and you are good to go. Advanced Usage: If you want more control over how to configure validation, you can set the supported validation options via the Camouflage method setupValidationWithOptions Enable it via config { // Other Camouflage options \"validation\": { \"enable\": true } } And then configure rest of the options as you wish camouflageHttp.setupValidationWithOptions({ apiSpec: \"./openapi.yaml\", validateRequests: true, validateResponses: true, // Other options });","title":"OpenAPI Validation"},{"location":"http/#compression","text":"You can optionally enable the compression options via config.json. Once enabled, compression is applied on all the routes, however you can restrict this behaviour using the setupCompressionWithOptions method and available options Enable compression in config.json { // Other Camouflage options \"compression\": true } Then provide required options function shouldCompress(req, res) { if (req.headers[\"x-no-compression\"]) { // don't compress responses with this request header return false; } // fallback to standard filter function return compression.filter(req, res); } camouflageHttp.setupCompressionWithOptions({ filter: shouldCompress });","title":"Compression"}]}